---
description: 
globs: 
alwaysApply: true
---
The prompt describes a request for a MERN stack application. While the original request focused on a Next.js 14 stack, the updated request for MERN changes the technical stack. I will provide a MERN stack approach based on the principles outlined, adapting them where necessary for the MERN context.

The MERN (MongoDB, Express.js, React, Node.js) stack is a popular choice for building full-stack web applications. It leverages JavaScript/TypeScript across the entire application, enabling a consistent development experience.

Here's a breakdown of how the key principles and conventions translate to a MERN stack application:

MERN Stack Architecture
Backend (Node.js with Express.js)
Purpose: Handles API requests, database interactions, authentication, and business logic.
Key Technologies:
Node.js: The JavaScript runtime.
Express.js: A fast, unopinionated, minimalist web framework for Node.js.
MongoDB: A NoSQL document database for storing application data.
Mongoose: An ODM (Object Data Modeling) library for MongoDB and Node.js, providing schema validation and easy interaction with the database.
TypeScript: For type safety throughout the backend.
Zod: For input validation on API routes.
JWT (JSON Web Tokens): For authentication.
Bcrypt: For password hashing.
Directory Structure:
src/
config/: Environment variables, database connection.
models/: Mongoose schemas.
controllers/: Business logic, request handling.
routes/: API routes.
middleware/: Authentication, error handling, validation.
services/: Encapsulate database interactions and complex logic.
utils/: Helper functions.
app.ts: Express application setup.
server.ts: Entry point to start the server.
Principles Application:
Functional, Declarative Programming: Controllers and services will be structured using pure functions.
Iteration and Modularization: Break down logic into small, reusable modules (e.g., separate files for routes, controllers, services).
Descriptive Variable Names: Use isValidUser, hasPermission.
TypeScript: All backend code will be in TypeScript. Interfaces will be preferred for data structures (e.g., IUser, IProduct).
Error Handling:
Implement custom error classes (e.g., AppError) for consistent error handling.
Use middleware for centralized error handling to catch unhandled exceptions and send appropriate responses.
Guard clauses at the beginning of controller functions for input validation and preconditions.
Services will throw user-friendly errors that can be caught by controllers and propagated.
RORO Pattern: API responses will follow a consistent success, data, error structure.
Frontend (React with Vite)
Purpose: User interface, user interaction, consuming backend APIs.
Key Technologies:
React: A JavaScript library for building user interfaces.
Vite: A fast build tool for modern web projects, used for quick development setup.
TypeScript: For type safety in React components and application logic.
Shadcn UI, Radix UI, Tailwind Aria: For pre-built, accessible, and highly customizable UI components and styling.
Tailwind CSS: For utility-first CSS styling, enabling responsive design.
TanStack Query (React Query): For efficient data fetching, caching, and state management.
Zod: For client-side form validation, often integrated with React Hook Form.
React Hook Form: For robust and flexible form management.
Axios or Fetch API: For making HTTP requests to the backend.
Directory Structure:
src/
components/: Reusable UI components (e.g., button, dialog).
features/: Feature-specific components and logic (e.g., auth, products).
hooks/: Custom React hooks.
services/: API client functions that interact with the backend.
utils/: Frontend utility functions.
types/: Global TypeScript interfaces and types.
assets/: Images, icons.
App.tsx: Root component.
main.tsx: Entry point for React application.
Principles Application:
Functional Components: All React components will be pure functions.
Declarative JSX: Focus on what to render, not how.
Shadcn UI, Radix UI, Tailwind Aria: Utilize these libraries for a consistent and accessible UI.
Responsive Design (Mobile-First): Implement Tailwind CSS breakpoints for mobile-first responsiveness.
Static Content and Interfaces at File End: Organize component files with static content and interfaces at the bottom.
Content Variables: Store static text content in variables outside render functions.
Minimize State: Leverage TanStack Query for data fetching state, reducing the need for useState for fetched data.
Zod for Form Validation: Integrate Zod with React Hook Form for client-side validation.
Error Handling:
TanStack Query's error handling mechanisms will be used to display user-friendly error messages from the backend.
React Error Boundaries can be used for unexpected rendering errors.
Image Optimization: If serving images from the frontend, use WebP, size data, and lazy loading.
RORO Pattern for API Calls: Services will return objects with success and data or error properties.
Database (MongoDB)
Purpose: Persistent storage for application data.
Key Technologies:
MongoDB: A NoSQL document database.
Mongoose: Node.js ODM for MongoDB.
Principles Application:
Schema Definition: Use Mongoose schemas to define the structure and validation rules for documents.
Data Modeling: Design efficient document structures for your application's needs.
Cross-Cutting Concerns
TypeScript Everywhere: Enforce strict TypeScript usage across the entire stack for better maintainability and fewer bugs.
Consistent Error Handling: Implement a unified error handling strategy across frontend and backend.
Environment Variables: Use .env files for configuration.
Testing: Implement unit and integration tests for both frontend and backend (e.g., Jest, React Testing Library, Supertest).
Example: User Authentication (Simplified)
This example demonstrates the application of some principles for a MERN stack.

Backend (src/routes/auth.ts)
TypeScript

// src/routes/auth.ts
import { Router } from 'express'
import { registerUser, loginUser } from '../controllers/auth'
import { validate } from '../middleware/validate'
import { registerSchema, loginSchema } from '../utils/validationSchemas'

const authRouter = Router()

authRouter.post('/register', validate(registerSchema), registerUser)
authRouter.post('/login', validate(loginSchema), loginUser)

export default authRouter
Backend (src/controllers/auth.ts)
TypeScript

// src/controllers/auth.ts
import { Request, Response, NextFunction } from 'express'
import { registerService, loginService } from '../services/auth'
import { AppError, appErrors } from '../utils/appErrors'
import { ILoginInput, IRegisterInput } from '../types/auth'

export async function registerUser(req: Request, res: Response, next: NextFunction) {
  const registerInput: IRegisterInput = req.body

  // Guard clause for missing input, though validation middleware handles most cases
  if (!registerInput || !registerInput.email || !registerInput.password) {
    return next(new AppError(appErrors.BAD_REQUEST, 'Missing registration credentials'))
  }

  try {
    const { success, data, error } = await registerService(registerInput)
    if (!success) {
      return next(error) // Propagate the error to error handling middleware
    }
    return res.status(201).json({ success: true, data })
  } catch (error) {
    next(error) // Catch unexpected errors
  }
}

export async function loginUser(req: Request, res: Response, next: NextFunction) {
  const loginInput: ILoginInput = req.body

  if (!loginInput || !loginInput.email || !loginInput.password) {
    return next(new AppError(appErrors.BAD_REQUEST, 'Missing login credentials'))
  }

  try {
    const { success, data, error } = await loginService(loginInput)
    if (!success) {
      return next(error)
    }
    return res.status(200).json({ success: true, data })
  } catch (error) {
    next(error)
  }
}
Backend (src/services/auth.ts)
TypeScript

// src/services/auth.ts
import User from '../models/User'
import { AppError, appErrors } from '../utils/appErrors'
import { hashPassword, comparePassword } from '../utils/authUtils' // Helper for bcrypt
import { generateToken } from '../utils/jwtUtils' // Helper for JWT
import { ILoginInput, IRegisterInput, IServiceResponse, IUserData } from '../types/auth'

export async function registerService(input: IRegisterInput): Promise<IServiceResponse<IUserData>> {
  const { email, password, name } = input

  const existingUser = await User.findOne({ email })
  if (existingUser) {
    return { success: false, error: new AppError(appErrors.USER_ALREADY_EXISTS, 'User with this email already exists') }
  }

  const hashedPassword = await hashPassword(password)
  const newUser = new User({ email, password: hashedPassword, name })
  await newUser.save()

  // Omit password from response
  const userData: IUserData = { id: newUser._id.toString(), email: newUser.email, name: newUser.name }
  return { success: true, data: userData }
}

export async function loginService(input: ILoginInput): Promise<IServiceResponse<{ token: string; user: IUserData }>> {
  const { email, password } = input

  const user = await User.findOne({ email })
  if (!user) {
    return { success: false, error: new AppError(appErrors.INVALID_CREDENTIALS, 'Invalid email or password') }
  }

  const isMatch = await comparePassword(password, user.password)
  if (!isMatch) {
    return { success: false, error: new AppError(appErrors.INVALID_CREDENTIALS, 'Invalid email or password') }
  }

  const token = generateToken(user._id.toString())
  const userData: IUserData = { id: user._id.toString(), email: user.email, name: user.name }

  return { success: true, data: { token, user: userData } }
}
Frontend (src/services/auth.ts)
TypeScript

// src/services/auth.ts
import axios from 'axios'
import type { ILoginInput, IRegisterInput, IAuthResponse } from '@/types/auth'

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:5000/api'

export async function registerUserClient(credentials: IRegisterInput): Promise<IAuthResponse> {
  try {
    const response = await axios.post(`${API_BASE_URL}/auth/register`, credentials)
    return { success: true, data: response.data.data }
  } catch (error) {
    if (axios.isAxiosError(error) && error.response) {
      // Backend errors will have an 'error' object in data from our RORO pattern
      return { success: false, error: error.response.data.error || 'Registration failed' }
    }
    return { success: false, error: 'An unexpected error occurred during registration.' }
  }
}

export async function loginUserClient(credentials: ILoginInput): Promise<IAuthResponse> {
  try {
    const response = await axios.post(`${API_BASE_URL}/auth/login`, credentials)
    return { success: true, data: response.data.data }
  } catch (error) {
    if (axios.isAxiosError(error) && error.response) {
      return { success: false, error: error.response.data.error || 'Login failed' }
    }
    return { success: false, error: 'An unexpected error occurred during login.' }
  }
}
Frontend (src/features/auth/AuthForm.tsx)
TypeScript

// src/features/auth/AuthForm.tsx
'use client' // This component needs client-side interactivity

import { useState } from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { Button } from '@/components/ui/button' // Shadcn UI Button
import { Input } from '@/components/ui/input'   // Shadcn UI Input
import { Label } from '@/components/ui/label'  // Shadcn UI Label
import { useMutation } from '@tanstack/react-query'
import { loginUserClient, registerUserClient } from '@/services/auth'
import type { ILoginInput, IRegisterInput } from '@/types/auth'

// Zod schemas for validation
const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
})

const registerSchema = z.object({
  name: z.string().min(2, 'Name is required'),
  email: z.string().email('Invalid email address'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
})

interface AuthFormProps {
  isRegisterMode: boolean
  onAuthSuccess: () => void
}

function AuthForm({ isRegisterMode, onAuthSuccess }: AuthFormProps) {
  const { register, handleSubmit, formState: { errors } } = useForm<ILoginInput | IRegisterInput>({
    resolver: zodResolver(isRegisterMode ? registerSchema : loginSchema),
  })

  const [errorMessage, setErrorMessage] = useState<string | null>(null)

  const { mutate: performLogin, isPending: isLoggingIn } = useMutation({
    mutationFn: loginUserClient,
    onSuccess: (response) => {
      if (response.success) {
        // Handle successful login (e.g., store token, redirect)
        console.log('Login successful:', response.data)
        onAuthSuccess()
      } else {
        setErrorMessage(response.error as string) // Display backend error
      }
    },
    onError: (error) => {
      setErrorMessage(loginContent.unexpectedError)
      console.error('Login error:', error)
    },
  })

  const { mutate: performRegister, isPending: isRegistering } = useMutation({
    mutationFn: registerUserClient,
    onSuccess: (response) => {
      if (response.success) {
        console.log('Registration successful:', response.data)
        onAuthSuccess()
      } else {
        setErrorMessage(response.error as string)
      }
    },
    onError: (error) => {
      setErrorMessage(registerContent.unexpectedError)
      console.error('Registration error:', error)
    },
  })

  function onSubmit(data: ILoginInput | IRegisterInput) {
    setErrorMessage(null) // Clear previous errors
    if (isRegisterMode) {
      performRegister(data as IRegisterInput)
    } else {
      performLogin(data as ILoginInput)
    }
  }

  const isLoading = isLoggingIn || isRegistering
  const formTitle = isRegisterMode ? registerContent.title : loginContent.title
  const submitButtonText = isRegisterMode ? registerContent.submitButton : loginContent.submitButton

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4 p-4 max-w-sm mx-auto">
      <h2 className="text-2xl font-bold text-center">{formTitle}</h2>

      {errorMessage && (
        <p className="text-red-500 text-sm text-center">{errorMessage}</p>
      )}

      {isRegisterMode && (
        <div>
          <Label htmlFor="name">{registerContent.nameLabel}</Label>
          <Input id="name" {...register('name')} disabled={isLoading} />
          {errors.name && <p className="text-red-500 text-xs">{errors.name.message}</p>}
        </div>
      )}

      <div>
        <Label htmlFor="email">{loginContent.emailLabel}</Label>
        <Input id="email" type="email" {...register('email')} disabled={isLoading} />
        {errors.email && <p className="text-red-500 text-xs">{errors.email.message}</p>}
      </div>

      <div>
        <Label htmlFor="password">{loginContent.passwordLabel}</Label>
        <Input id="password" type="password" {...register('password')} disabled={isLoading} />
        {errors.password && <p className="text-red-500 text-xs">{errors.password.message}</p>}
      </div>

      <Button type="submit" className="w-full" disabled={isLoading}>
        {isLoading ? (isRegisterMode ? registerContent.loadingText : loginContent.loadingText) : submitButtonText}
      </Button>
    </form>
  )
}

export default AuthForm

// Static content
const loginContent = {
  title: 'Login',
  emailLabel: 'Email',
  passwordLabel: 'Password',
  submitButton: 'Log In',
  loadingText: 'Logging in...',
  unexpectedError: 'An unexpected error occurred. Please try again.',
}

const registerContent = {
  title: 'Register',
  nameLabel: 'Name',
  emailLabel: 'Email',
  passwordLabel: 'Password',
  submitButton: 'Register',
  loadingText: 'Registering...',
  unexpectedError: 'An unexpected error occurred. Please try again.',
}